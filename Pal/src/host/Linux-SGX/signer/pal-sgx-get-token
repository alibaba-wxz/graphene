#!/usr/bin/env python3

import argparse
import binascii
import os
import sys
import struct
import socket
from google.protobuf import message as _message
import aesm_pb2

from utils import *

sys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))
from generated_offsets import *

""" Reading Sigstruct """

def read_sigstruct(sig):
    # field format: (offset, type, value)
    # SGX_ARCH_SIGSTRUCT_
    fields = {
        'date'     : (SGX_ARCH_SIGSTRUCT_DATE, "<HBB", 'year', 'month', 'day'),
        'modulus'  : (SGX_ARCH_SIGSTRUCT_MODULUS, "384s", 'modulus'),
        'exponent' : (SGX_ARCH_SIGSTRUCT_EXPONENT, "<L",   'exponent'),
        'signature': (SGX_ARCH_SIGSTRUCT_SIGNATURE, "384s", 'signature'),

        'miscs'    : (SGX_ARCH_SIGSTRUCT_MISCSELECT, "4s", 'miscs'),
        'miscmask' : (SGX_ARCH_SIGSTRUCT_MISCSELECT_MASK, "4s", 'miscmask'),
        'attrs'    : (SGX_ARCH_SIGSTRUCT_ATTRIBUTES, "8s8s", 'flags', 'xfrms'),
        'attrmask' : (SGX_ARCH_SIGSTRUCT_ATTRIBUTES_MASK,
                      "8s8s", 'flagmask', 'xfrmmask'),
        'mrenclave': (SGX_ARCH_SIGSTRUCT_ENCLAVE_HASH, "32s", 'mrenclave'),
        'isvprodid': (SGX_ARCH_SIGSTRUCT_ISVPRODID, "<H", 'isvprodid'),
        'isvsvn'   : (SGX_ARCH_SIGSTRUCT_ISVSVN, "<H", 'isvsvn'),
    }

    attr = dict()
    for key, field in fields.items():
        values = struct.unpack_from(field[1], sig, field[0])

        for i in range(len(values)):
            attr[field[i + 2]] = values[i]

    return attr

""" Connect with AESMD """

def connect_aesmd(attr):
    req_msg = aesm_pb2.GetTokenReq()
    req_msg.req.signature = attr['mrenclave']
    req_msg.req.key = attr['modulus']
    req_msg.req.attributes = attr['flags'] + attr['xfrms']
    req_msg.req.timeout = 10000

    req_msg_raw = req_msg.SerializeToString()

    aesm_service = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    connected = False

    # try to connect to the unnamed socket (for PSW 1.6 and 1.7)
    if not connected:
        try:
            aesm_service.connect("\0sgx_aesm_socket_base" + "\0" * 87)
            connected = True
        except socket.error:
            pass

    # try to connect to the named socket (for PSW 1.8+)
    if not connected:
        try:
            aesm_service.connect("/var/run/aesmd/aesm.socket")
            connected = True
        except socket.error:
            pass

    if not connected:
        raise socket.error("Cannot connect to the AESMD service")

    aesm_service.send(struct.pack("<I", len(req_msg_raw)))
    aesm_service.send(req_msg_raw)

    ret_msg_size = struct.unpack("<I", aesm_service.recv(4))[0]
    ret_msg = aesm_pb2.GetTokenRet()
    ret_msg_raw = aesm_service.recv(ret_msg_size)
    ret_msg.ParseFromString(ret_msg_raw)

    if ret_msg.ret.error != 0:
        raise Exception("Failed. (Error Code = %d)" % (ret_msg.ret.error))

    return ret_msg.ret.token

""" Main Program """

argparser = argparse.ArgumentParser()
argparser.add_argument('--sig', '-sig', metavar='SIGNATURE',
                       type=argparse.FileType('rb'), nargs=1, required=True,
                       help='specify .sig file')
argparser.add_argument('--output', '-output', metavar='OUTPUT',
                       type=argparse.FileType('wb'), nargs=1, required=True,
                       help='specify output(.token) file')

if __name__ == "__main__":
    args = argparser.parse_args(sys.argv[1:])

    attr = read_sigstruct(args.sig[0].read())

    print("Attributes:")
    print("    mrenclave: %s" % attr['mrenclave'].hex())
    print("    isvprodid: %d" % attr['isvprodid'])
    print("    isvsvn:    %d" % attr['isvsvn'])
    print("    flags:     %016x" % bytes_to_int(attr['flags']))
    print("    xfrms:     %016x" % bytes_to_int(attr['xfrms']))
    print("    miscs:     %08x"  % bytes_to_int(attr['miscs']))
    print("    miscmask:  %08x"  % bytes_to_int(attr['miscmask']))
    print("    modulus:   %s..." % attr['modulus'].hex()[:32])
    print("    exponent:  %d" % attr['exponent'])
    print("    signature: %s..." % attr['signature'].hex()[:32])

    token = connect_aesmd(attr)
    args.output[0].write(token)
